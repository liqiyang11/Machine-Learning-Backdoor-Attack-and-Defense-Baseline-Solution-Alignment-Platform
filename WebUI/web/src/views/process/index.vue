<template>
  <div class="p-4 space-y-4 bg-gray-50 min-h-screen font-sans text-gray-700 ">
    <!-- Page Header -->
    <div class="flex items-center justify-between mb-2">
      <h2 class="text-xl font-bold text-gray-800 tracking-tight">æµ‹è¯„è¿‡ç¨‹ (Evaluation Process)</h2>
      <div class="text-sm text-gray-500">System Status: <span class="text-primary-600 font-medium">Running</span></div>
    </div>

    <!-- Main Grid Layout -->
    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
      <!-- Left Column: Three Accelerator Balls -->
      <div class="md:col-span-1 space-y-4">
        <!-- æ”»å‡»è¯„ä¼°åŠ é€Ÿçƒ -->
        <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-6 flex flex-col items-center justify-center relative overflow-hidden h-[250px]">
          <h3 class="text-xl font-semibold mb-4 text-gray-800 w-full text-center">æ”»å‡»è¯„ä¼°</h3>
          
          <!-- Accelerator Ball Container -->
          <div class="relative w-36 h-36">
            <!-- Outer Ring -->
            <div 
              class="absolute inset-0 rounded-full border-4 border-opacity-20 animate-pulse"
              :style="{ borderColor: getStageColor('æ”»å‡»è¯„ä¼°').bg }"
            ></div>
            
            <!-- The Liquid Ball -->
            <div 
              class="w-full h-full rounded-full overflow-hidden relative shadow-inner flex items-center justify-center"
              :style="{ 
                backgroundColor: getStageColor('æ”»å‡»è¯„ä¼°').bg,
                boxShadow: `0 0 20px ${getStageColor('æ”»å‡»è¯„ä¼°').bg}`
              }"
            >
              <!-- Wave Animation Background -->
              <div 
                class="absolute bottom-0 left-0 right-0 transition-all duration-1000 ease-linear opacity-80"
                :style="{ 
                  height: `${stageScores['æ”»å‡»è¯„ä¼°']}%`, 
                  backgroundColor: getStageColor('æ”»å‡»è¯„ä¼°').liquid,
                  filter: 'blur(1px)'
                }"
              >
                <!-- Wave SVG overlay for liquid effect -->
                <div class="absolute -top-4 left-0 w-[200%] h-6 animate-wave" 
                     :style="{ fill: getStageColor('æ”»å‡»è¯„ä¼°').liquid }">
                  <svg viewBox="0 0 1200 120" preserveAspectRatio="none" class="w-full h-full opacity-50">
                    <path d="M321.39,56.44c58-10.79,114.16-30.13,172-41.86,82.39-16.72,168.19-17.73,250.45-.39C823.78,31,906.67,72,985.66,92.83c70.05,18.48,146.53,26.09,214.34,3V0H0V27.35A600.21,600.21,0,0,0,321.39,56.44Z" fill="currentColor"></path>
                  </svg>
                </div>
              </div>

              <!-- Score Text -->
              <div class="relative z-10 text-4xl font-bold transition-colors duration-300" style="color: white;">
                {{ Math.round(stageScores['æ”»å‡»è¯„ä¼°']) }}
              </div>
            </div>
          </div>
        </div>

        <!-- åé—¨æ£€æµ‹ä¸ä¿®å¤åŠ é€Ÿçƒ -->
        <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-6 flex flex-col items-center justify-center relative overflow-hidden h-[250px]">
          <h3 class="text-xl font-semibold mb-4 text-gray-800 w-full text-center">æ¨¡å‹å®‰å…¨åˆ†æ•°</h3>
          
          <!-- Accelerator Ball Container -->
          <div class="relative w-36 h-36">
            <!-- Outer Ring -->
            <div 
              class="absolute inset-0 rounded-full border-4 border-opacity-20 animate-pulse"
              :style="{ borderColor: getStageColor('åé—¨æ£€æµ‹ä¸ä¿®å¤').bg }"
            ></div>
            
            <!-- The Liquid Ball -->
            <div 
              class="w-full h-full rounded-full overflow-hidden relative shadow-inner flex items-center justify-center"
              :style="{ 
                backgroundColor: getStageColor('åé—¨æ£€æµ‹ä¸ä¿®å¤').bg,
                boxShadow: `0 0 20px ${getStageColor('åé—¨æ£€æµ‹ä¸ä¿®å¤').bg}`
              }"
            >

              <!-- Wave Animation Background -->
              <div 
                class="absolute bottom-0 left-0 right-0 transition-all duration-1000 ease-linear opacity-80"
                :style="{ 
                  height: `${stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤']}%`, 
                  backgroundColor: getStageColor('åé—¨æ£€æµ‹ä¸ä¿®å¤').liquid,
                  filter: 'blur(1px)'
                }"
              >
                <!-- Wave SVG overlay for liquid effect -->
                <div class="absolute -top-4 left-0 w-[200%] h-6 animate-wave" 
                     :style="{ fill: getStageColor('åé—¨æ£€æµ‹ä¸ä¿®å¤').liquid }">
                  <svg viewBox="0 0 1200 120" preserveAspectRatio="none" class="w-full h-full opacity-50">
                    <path d="M321.39,56.44c58-10.79,114.16-30.13,172-41.86,82.39-16.72,168.19-17.73,250.45-.39C823.78,31,906.67,72,985.66,92.83c70.05,18.48,146.53,26.09,214.34,3V0H0V27.35A600.21,600.21,0,0,0,321.39,56.44Z" fill="currentColor"></path>
                  </svg>
                </div>
              </div>

              <!-- Score Text -->
              <div class="relative z-10 text-4xl font-bold transition-colors duration-300" style="color: white;">
                {{ Math.round(stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤']) }}
              </div>
            </div>
          </div>
        </div>

        <!-- ä¿®å¤åè¯„ä¼°åŠ é€Ÿçƒ -->
        <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-6 flex flex-col items-center justify-center relative overflow-hidden h-[250px]">
          <h3 class="text-xl font-semibold mb-4 text-gray-800 w-full text-center">ä¿®å¤åè¯„ä¼°</h3>
          
          <!-- Accelerator Ball Container -->
          <div class="relative w-36 h-36">
            <!-- Outer Ring -->
            <div 
              class="absolute inset-0 rounded-full border-4 border-opacity-20 animate-pulse"
              :style="{ borderColor: getStageColor('ä¿®å¤åè¯„ä¼°').bg }"
            ></div>
            
            <!-- The Liquid Ball -->
            <div 
              class="w-full h-full rounded-full overflow-hidden relative shadow-inner flex items-center justify-center"
              :style="{ 
                backgroundColor: getStageColor('ä¿®å¤åè¯„ä¼°').bg,
                boxShadow: `0 0 20px ${getStageColor('ä¿®å¤åè¯„ä¼°').bg}`
              }"
            >

              <!-- Wave Animation Background -->
              <div 
                class="absolute bottom-0 left-0 right-0 transition-all duration-1000 ease-linear opacity-80"
                :style="{ 
                  height: `${stageScores['ä¿®å¤åè¯„ä¼°']}%`, 
                  backgroundColor: getStageColor('ä¿®å¤åè¯„ä¼°').liquid,
                  filter: 'blur(1px)'
                }"
              >
                <!-- Wave SVG overlay for liquid effect -->
                <div class="absolute -top-4 left-0 w-[200%] h-6 animate-wave" 
                     :style="{ fill: getStageColor('ä¿®å¤åè¯„ä¼°').liquid }">
                  <svg viewBox="0 0 1200 120" preserveAspectRatio="none" class="w-full h-full opacity-50">
                    <path d="M321.39,56.44c58-10.79,114.16-30.13,172-41.86,82.39-16.72,168.19-17.73,250.45-.39C823.78,31,906.67,72,985.66,92.83c70.05,18.48,146.53,26.09,214.34,3V0H0V27.35A600.21,600.21,0,0,0,321.39,56.44Z" fill="currentColor"></path>
                  </svg>
                </div>
              </div>

              <!-- Score Text -->
              <div class="relative z-10 text-4xl font-bold transition-colors duration-300" style="color: white;">
                {{ Math.round(stageScores['ä¿®å¤åè¯„ä¼°']) }}
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Columns: Stage Details -->
      <!-- ä¿®æ”¹ä¸»ç½‘æ ¼å¸ƒå±€ -->
      <div class="md:col-span-3 grid grid-cols-1 lg:grid-cols-5 gap-4">
      <!-- Module 1: æ”»å‡»è¯„ä¼° -->
      <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-0 flex flex-col h-full min-h-[770px] overflow-hidden lg:col-span-1">
      <div class="p-4 border-b border-gray-100 flex items-center gap-2 bg-gray-50/50">
        <div class="w-8 h-8 rounded-lg bg-blue-50 flex items-center justify-center text-blue-600">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12V7H5a2 2 0 0 1 0-4h14v4"/><path d="M3 5v14a2 2 0 0 0 2 2h16v-5"/><path d="M18 12a2 2 0 0 0 0 4h4v-4Z"/></svg>
        </div>
        <h3 class="text-xl font-semibold text-gray-800">æ”»å‡»è¯„ä¼°</h3>
      </div>
      <div class="flex-1 overflow-y-auto p-2 space-y-1 custom-scrollbar">
        <div v-for="(type, method) in stages['æ”»å‡»è¯„ä¼°']" :key="method" 
               class="flex items-center justify-between p-3 rounded-lg transition-colors hover:bg-gray-50 border border-transparent"
               :class="{'bg-blue-50/30 border-blue-100': currentMethod === method}">
          <span class="text-xl font-medium" :class="getMethodColor(type)">{{ method }}</span>
          <StatusIcon :status="methodStatuses[method]" />
        </div>
      </div>
    </div>
  
  <!-- Module 2: åé—¨æ£€æµ‹ä¸ä¿®å¤ (åŒ…å«ä¸‰ä¸ªå­æ¨¡å—) -->
  <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-0 flex flex-col h-full min-h-[770px] overflow-hidden lg:col-span-3">
  <div class="p-4 border-b border-gray-100 flex items-center gap-2 bg-gray-50/50">
    <div class="w-8 h-8 rounded-lg bg-purple-50 flex items-center justify-center text-purple-600">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4"/><path d="m16.2 7.8 2.9-2.9"/><path d="M18 12h4"/><path d="m16.2 16.2 2.9 2.9"/><path d="M12 18v4"/><path d="m4.9 19.1 2.9-2.9"/><path d="M2 12h4"/><path d="m4.9 4.9 2.9 2.9"/></svg>
    </div>
    <h3 class="text-xl font-semibold text-gray-800">åé—¨æ£€æµ‹ä¸ä¿®å¤</h3>
  </div>
  <div class="flex-1 overflow-y-auto p-2 custom-scrollbar">
    <!-- å­æ¨¡å—å®¹å™¨ - æ¨ªå‘æ’åˆ— -->
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
      <!-- æ•°æ®å¤„ç†é˜¶æ®µå­æ¨¡å— -->
      <div class="bg-purple-50/20 rounded-lg p-2">
        <h4 class="text-xl font-medium text-purple-700 mb-2 text-center">æ•°æ®å¤„ç†é˜¶æ®µ</h4>
        <div class="space-y-1">
          <div v-for="(type, method) in stages['åé—¨æ£€æµ‹ä¸ä¿®å¤']['æ•°æ®å¤„ç†é˜¶æ®µ']" :key="method" 
               class="flex items-center justify-between p-2 rounded-lg transition-colors hover:bg-white border border-transparent"
               :class="{'bg-white border-purple-100': currentMethod === method}">
            <span class="text-xl font-medium" :class="getMethodColor(type)">{{ method }}</span>
            <StatusIcon :status="methodStatuses[method]" />
          </div>
        </div>
      </div>
      
      <!-- æ¨¡å‹è®­ç»ƒé˜¶æ®µå­æ¨¡å— -->
      <div class="bg-purple-50/20 rounded-lg p-2">
        <h4 class="text-xl font-medium text-purple-700 mb-2 text-center">æ¨¡å‹è®­ç»ƒé˜¶æ®µ</h4>
        <div class="space-y-1">
          <div v-for="(type, method) in stages['åé—¨æ£€æµ‹ä¸ä¿®å¤']['æ¨¡å‹è®­ç»ƒé˜¶æ®µ']" :key="method" 
               class="flex items-center justify-between p-2 rounded-lg transition-colors hover:bg-white border border-transparent"
               :class="{'bg-white border-purple-100': currentMethod === method}">
            <span class="text-xl font-medium" :class="getMethodColor(type)">{{ method }}</span>
            <StatusIcon :status="methodStatuses[method]" />
          </div>
        </div>
      </div>
      
      <!-- æ¨¡å‹è¯„ä¼°é˜¶æ®µå­æ¨¡å— -->
      <div class="bg-purple-50/20 rounded-lg p-2">
        <h4 class="text-xl font-medium text-purple-700 mb-2 text-center">æ¨¡å‹è¯„ä¼°é˜¶æ®µ</h4>
        <div class="space-y-1">
          <div v-for="(type, method) in stages['åé—¨æ£€æµ‹ä¸ä¿®å¤']['æ¨¡å‹è¯„ä¼°é˜¶æ®µ']" :key="method" 
               class="flex items-center justify-between p-2 rounded-lg transition-colors hover:bg-white border border-transparent"
               :class="{'bg-white border-purple-100': currentMethod === method}">
            <span class="text-xl font-medium" :class="getMethodColor(type)">{{ method }}</span>
            <StatusIcon :status="methodStatuses[method]" />
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <!-- Module 3: ä¿®å¤åè¯„ä¼° -->
  <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-0 flex flex-col h-full min-h-[770px] overflow-hidden lg:col-span-1">
  <div class="p-4 border-b border-gray-100 flex items-center gap-2 bg-gray-50/50">
    <div class="w-8 h-8 rounded-lg bg-green-50 flex items-center justify-center text-green-600">
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/><path d="m9 12 2 2 4-4"/></svg>
    </div>
    <h3 class="text-xl font-semibold text-gray-800">ä¿®å¤åè¯„ä¼°</h3>
  </div>
  <div class="flex-1 overflow-y-auto p-2 space-y-1 custom-scrollbar">
    <div v-for="(type, method) in stages['ä¿®å¤åè¯„ä¼°']" :key="method" 
           class="flex items-center justify-between p-3 rounded-lg transition-colors hover:bg-gray-50 border border-transparent"
           :class="{'bg-green-50/30 border-green-100': currentMethod === method}">
      <span class="text-xl font-medium" :class="getMethodColor(type)">{{ method }}</span>
      <StatusIcon :status="methodStatuses[method]" />
    </div>
  </div>
</div>
      </div>
    </div>

    <!-- åœ¨Current Status Infoä¸Šæ–¹æ·»åŠ ä¼˜åŒ–åçš„å›¾ä¾‹ -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-3">
      <h4 class="text-xl font-semibold mb-2 text-gray-800">å›¾ä¾‹è¯´æ˜</h4>
      <div class="flex flex-wrap gap-4">
        <!-- å®‰å…¨çŠ¶æ€å›¾ä¾‹ -->
        <div class="flex items-center gap-1">
          <div class="w-3 h-3 rounded-full bg-green-500 shadow-sm"></div>
          <span class="text-xl text-gray-700">å®‰å…¨</span>
        </div>
        <div class="flex items-center gap-1">
          <div class="w-3 h-3 rounded-full bg-yellow-500 shadow-sm"></div>
          <span class="text-xl text-gray-700">ä½å±</span>
        </div>
        <div class="flex items-center gap-1">
          <div class="w-3 h-3 rounded-full bg-red-500 shadow-sm"></div>
          <span class="text-xl text-gray-700">é«˜å±</span>
        </div>
        
        <!-- æ“ä½œç±»å‹å›¾ä¾‹ -->
        <div class="flex items-center gap-1">
          <span class="text-xl font-medium text-red-500">æ”»å‡»æ¨¡æ‹Ÿ</span>
        </div>
        <div class="flex items-center gap-1">
          <span class="text-xl font-medium text-blue-500">æ£€æµ‹æ–¹æ¡ˆ</span>
        </div>
        <div class="flex items-center gap-1">
          <span class="text-xl font-medium text-green-500">ä¿®å¤æ–¹æ¡ˆ</span>
        </div>
      </div>
    </div>
    
    <!-- åŸæœ‰çš„Current Status Infoéƒ¨åˆ† -->
    <div class="bg-white rounded-xl shadow-sm border border-gray-100 p-4 mt-4">
      <div class="text-sm text-gray-500 text-center">
        <p v-if="isEvaluating" class="animate-pulse font-medium">æ­£åœ¨æ‰§è¡Œ: {{ currentMethod || 'åˆå§‹åŒ–...' }}</p>
        <p v-else class="font-medium text-green-600">è¯„ä¼°å®Œæˆ</p>
        <p class="text-xs text-gray-400">å½“å‰é˜¶æ®µ: {{ currentStage || 'å‡†å¤‡ä¸­' }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed, reactive, h } from 'vue'

// è·å–URLå‚æ•°
const getUrlParams = () => {
  const params = new URLSearchParams(window.location.search);
  return {
    config: params.get('config'),
    dataset: params.get('dataset')
  };
};

const { config, dataset } = getUrlParams();

/* ------------------------- 
   Stage Configurations
-------------------------- */
// åˆå§‹å®šä¹‰stages
let stages = {
    "æ”»å‡»è¯„ä¼°": {
        "BadNetsæ•°æ®æŠ•æ¯’": "æ”»å‡»æ¨¡æ‹Ÿ",
        "SSBAsæ•°æ®æŠ•æ¯’": "æ”»å‡»æ¨¡æ‹Ÿ",
        "CASSOCKæ”»å‡»è®­ç»ƒ": "æ”»å‡»æ¨¡æ‹Ÿ",
        "é€šç”¨è§¦å‘å™¨ç”Ÿæˆ": "æ”»å‡»æ¨¡æ‹Ÿ",
        "æ ·æœ¬ä¸“ç”¨è§¦å‘å™¨ç”Ÿæˆ": "æ”»å‡»æ¨¡æ‹Ÿ"
    },
    "åé—¨æ£€æµ‹ä¸ä¿®å¤": {
	"æ•°æ®å¤„ç†é˜¶æ®µ": {
		"SVD": "åé—¨æ£€æµ‹ä¸ä¿®å¤",
		"STRIP": "åé—¨æ£€æµ‹ä¸ä¿®å¤",
		"æ•°æ®æ¸…æ´—": "åé—¨ä¿®å¤",
		"æ•°æ®å¢å¼º": "åé—¨ä¿®å¤",
	},
	"æ¨¡å‹è®­ç»ƒé˜¶æ®µ": {
		"æ¢¯åº¦åŠ å™ª": "åé—¨ä¿®å¤",
		"æ ·æœ¬å¯¹é½": "åé—¨ä¿®å¤",
	},
	"æ¨¡å‹è¯„ä¼°é˜¶æ®µ": {
		"Neural Cleanse": "åé—¨æ£€æµ‹ä¸ä¿®å¤",
		"DeBackdoor": "åé—¨æ£€æµ‹ä¸ä¿®å¤",
		"Steps": "åé—¨æ£€æµ‹ä¸ä¿®å¤",
		"å‰ªæ": "åé—¨ä¿®å¤",
		"å¾®è°ƒ": "åé—¨ä¿®å¤",
		"æœºå™¨é—å¿˜": "åé—¨ä¿®å¤",
	},
    },
    "ä¿®å¤åè¯„ä¼°":{
        "BadNetsæ•ˆæœè¯„ä¼°": "æ”»å‡»æ¨¡æ‹Ÿ",
        "SSBAsæ•ˆæœè¯„ä¼°": "æ”»å‡»æ¨¡æ‹Ÿ",
        "CASSOCKæ•ˆæœè¯„ä¼°": "æ”»å‡»æ¨¡æ‹Ÿ",
        "é€šç”¨è§¦å‘å™¨æ•ˆæœè¯„ä¼°": "æ”»å‡»æ¨¡æ‹Ÿ",
        "æ ·æœ¬ä¸“ç”¨è§¦å‘å™¨æ•ˆæœè¯„ä¼°": "æ”»å‡»æ¨¡æ‹Ÿ"
    }
};

// æ ¹æ®datasetå‚æ•°ä¿®æ”¹stages
if (dataset && dataset.toLowerCase() !== 'mnist' && config) {
  try {
    // å°è¯•å°†configå‚æ•°è§£æä¸ºJSONå¹¶è®¾ç½®ä¸ºstages
    stages = JSON.parse(decodeURIComponent(config));
    console.log('æ ¹æ®configå‚æ•°æ›´æ–°äº†stagesé…ç½®');
  } catch (e) {
    console.error('è§£æconfigå‚æ•°å¤±è´¥:', e);
    // å¦‚æœè§£æå¤±è´¥ï¼Œä¿æŒåŸæœ‰stagesé…ç½®
  }
}

// ä¸ºæ¯ä¸ªé˜¶æ®µåˆ›å»ºç‹¬ç«‹çš„åˆ†æ•°çŠ¶æ€
const stageScores = reactive({
  "æ”»å‡»è¯„ä¼°": 100,
  "åé—¨æ£€æµ‹ä¸ä¿®å¤": 100,
  "ä¿®å¤åè¯„ä¼°": 100
})

const isEvaluating = ref(true)
const currentStage = ref('')
const currentMethod = ref('')
const methodStatuses = reactive({})

// åˆå§‹åŒ–çŠ¶æ€ï¼Œå¤„ç†åµŒå¥—ç»“æ„
const initializeMethodStatuses = () => {
  Object.values(stages).forEach(stageMethods => {
    // æ£€æŸ¥æ˜¯å¦ä¸ºåµŒå¥—ç»“æ„
    if (typeof stageMethods === 'object' && stageMethods !== null) {
      const isNested = Object.values(stageMethods).some(val => 
        typeof val === 'object' && val !== null
      );
      
      if (isNested) {
        // å¤„ç†åµŒå¥—ç»“æ„
        Object.values(stageMethods).forEach(subStageMethods => {
          Object.keys(subStageMethods).forEach(method => {
            methodStatuses[method] = 'pending'
          })
        })
      } else {
        // å¤„ç†éåµŒå¥—ç»“æ„
        Object.keys(stageMethods).forEach(method => {
          methodStatuses[method] = 'pending'
        })
      }
    }
  })
}

// åˆå§‹åŒ–æ–¹æ³•çŠ¶æ€
initializeMethodStatuses()

/* ------------------------- 
   Color Mapping Logic
-------------------------- */
const getStageColor = (stageName) => {
  const s = Math.max(0, Math.min(100, stageScores[stageName]))

  // GREEN >80 (lower = lighter)
  if (s > 80) {
    const t = (s - 80) / 20
    const r = 50 + (20 * t)
    const g = 220 + (25 * t)
    const b = 90 + (20 * t)
    return {
      liquid: `rgb(${r},${g},${b})`,
      bg: `rgba(${r},${g},${b},0.25)`
    }
  }

  // YELLOW 50â€“80 (lower = deeper)
  if (s > 50) {
    const t = (s - 50) / 30
    const r = 255
    const g = 160 + (90 * t)
    const b = 0
    return {
      liquid: `rgb(${r},${g},${b})`,
      bg: `rgba(${r},${g},${b},0.25)`
    }
  }

  // RED <50 (lower = darker)
  const t = s / 50
  const r = 200 + (55 * t)
  const g = 20 * t
  const b = 20 * t
  return {
    liquid: `rgb(${r},${g},${b})`,
    bg: `rgba(${r},${g},${b},0.25)`
  }
}

/* ------------------------- 
   UI Tools
-------------------------- */
const getMethodColor = (type) => {
  switch (type) {
    case 'æ”»å‡»æ¨¡æ‹Ÿ': return 'text-red-500'
    case 'åé—¨æ£€æµ‹ä¸ä¿®å¤': return 'text-blue-500'
    case 'åé—¨ä¿®å¤': return 'text-green-500'
    default: return 'text-gray-600'
  }
}

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms))

// status icon
const StatusIcon = (props) => {
  const { status } = props
  
  if (status === 'pending') {
    return h('div', { class: 'w-3 h-3 rounded-full bg-blue-200' })
  }
  
  if (status === 'running') {
    return h('div', { class: 'w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full animate-spin' })
  }
  
  let colorClass = 'bg-green-500'
  if (status === 'yellow') colorClass = 'bg-yellow-500'
  if (status === 'red') colorClass = 'bg-red-500'
  
  return h('div', { class: `w-3 h-3 rounded-full ${colorClass} shadow-sm` })
}

/* ------------------------- 
   Simulation Logic
-------------------------- */
const runSimulation = async () => {
  const stageNames = Object.keys(stages)

  for (const stageName of stageNames) {
    currentStage.value = stageName
    const methods = stages[stageName]

    const isNested = typeof methods === "object" &&
      Object.values(methods).some(v => typeof v === "object")

    // ç»Ÿä¸€ä¸€ä¸ªæ‰§è¡Œå‡½æ•°ï¼Œé¿å… continue ä¹±åºé—®é¢˜
    const executeMethod = async (methodName, stageName) => {
      currentMethod.value = methodName
      methodStatuses[methodName] = "running"

      /* ==========================================
         ğŸ”¥ åªè¦æ˜¯ CASSOCKæ”»å‡»è®­ç»ƒ â†’ å¼ºåˆ¶è°ƒç”¨åç«¯
      ========================================== */
      if (methodName === "é€šç”¨è§¦å‘å™¨ç”Ÿæˆ") {
        try {
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            "http://127.0.0.1:9999/api/v1/system-manage/ag/generate_trigger"
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("é€šç”¨è§¦å‘å™¨ç”Ÿæˆä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/ag/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/æ”»å‡»æˆåŠŸç‡\s*:\s*([0-9.]+)/);


              if (match) {
                finalMetric1 = parseFloat(match[1])
                console.log("å‰ç«¯è¯»å–åˆ°çš„ æ”»å‡»æˆåŠŸç‡", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° æ”»å‡»æˆåŠŸç‡ï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 3 : 5
          console.log("CASSOCK final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores["æ”»å‡»è¯„ä¼°"] = Math.max(0, stageScores["æ”»å‡»è¯„ä¼°"] - minusValue)

          methodStatuses[methodName] = "green"
          if (minusValue < 10) {
            methodStatuses[methodName] = "yellow"
          } else {
            methodStatuses[methodName] = "red"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores["æ”»å‡»è¯„ä¼°"] = Math.max(0, stageScores["æ”»å‡»è¯„ä¼°"] - 10)
          return
        }
      }

      

      else if (methodName === "æ ·æœ¬ä¸“ç”¨è§¦å‘å™¨ç”Ÿæˆ") {
        try {
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            "http://127.0.0.1:9999/api/v1/system-manage/ag/targeted_attack"
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("æ ·æœ¬ä¸“ç”¨è§¦å‘å™¨ç”Ÿæˆå·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/ag/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/Success rate\s*:\s*([0-9.]+)/);


              if (match) {
                finalMetric1 = parseFloat(match[1])
                console.log("å‰ç«¯è¯»å–åˆ°çš„ Success rate", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° Success rateï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 3 : 5
          console.log("CASSOCK final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores["æ”»å‡»è¯„ä¼°"] = Math.max(0, stageScores["æ”»å‡»è¯„ä¼°"] - minusValue)

          methodStatuses[methodName] = "green"
          if (minusValue < 10) {
            methodStatuses[methodName] = "yellow"
          } else {
            methodStatuses[methodName] = "red"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores["æ”»å‡»è¯„ä¼°"] = Math.max(0, stageScores["æ”»å‡»è¯„ä¼°"] - 10)
          return
        }
      }

      else if (methodName === "CASSOCKæ”»å‡»è®­ç»ƒ") {
        try {
          // ç¡®å®šå‚æ•°æ–‡ä»¶è·¯å¾„
          let paramsFile = "configs/mnist_params.yaml";
          if (dataset && dataset.toLowerCase() !== 'mnist') {
            paramsFile = "configs/gtsrb_params.yaml";
          }
          
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            `http://127.0.0.1:9999/api/v1/system-manage/backdoor/train?name=mnist&params_file=${paramsFile}&commit=none`
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("CASSOCKä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/backdoor/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/final_metric1\s*:\s*([0-9.]+)/);


              if (match) {
                finalMetric1 = parseFloat(match[1])
                console.log("å‰ç«¯è¯»å–åˆ°çš„ final_metric1 =", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° final_metric1ï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 3 : 5
          console.log("CASSOCK final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores["æ”»å‡»è¯„ä¼°"] = Math.max(0, stageScores["æ”»å‡»è¯„ä¼°"] - minusValue)

          methodStatuses[methodName] = "green"
          if (minusValue < 10) {
            methodStatuses[methodName] = "yellow"
          } else {
            methodStatuses[methodName] = "red"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores["æ”»å‡»è¯„ä¼°"] = Math.max(0, stageScores["æ”»å‡»è¯„ä¼°"] - 10)
          return
        }
      }

      else if (methodName === "SVD") {
        try {
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            "http://127.0.0.1:9999/api/v1/system-manage/datacheck/mnist_backdoor_detection"
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("SVDä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/datacheck/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/\d+\.\d+/);


              if (match) {
                finalMetric1 = parseFloat(match[0])*100
                console.log("å‰ç«¯è¯»å–åˆ°çš„ final_metric1 =", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° final_metric1ï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 5 : 5
          console.log("SVD final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - minusValue)

          
          if (minusValue > 10) {
            methodStatuses[methodName] = "red"
          } else if (minusValue > 4) {
            methodStatuses[methodName] = "yellow"
          }else {
            methodStatuses[methodName] = "green"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - 10)
          return
        }
      }

      else if (methodName === "STRIP") {
        try {
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            "http://127.0.0.1:9999/api/v1/system-manage/datacheck/strip_detection"
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("STRIPä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/datacheck/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/\d+\.\d+/);


              if (match) {
                finalMetric1 = parseFloat(match[0])
                console.log("å‰ç«¯è¯»å–åˆ°çš„ final_metric1 =", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° final_metric1ï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 5 : 5
          console.log("SVD final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - minusValue)

          
          if (minusValue > 10) {
            methodStatuses[methodName] = "red"
          } else if (minusValue > 4) {
            methodStatuses[methodName] = "yellow"
          }else {
            methodStatuses[methodName] = "green"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - 10)
          return
        }
      }
      else if (methodName === "Neural Cleanse") {
        try {
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            "http://127.0.0.1:9999/api/v1/system-manage/modelcheck/train_MNIST"
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("Neural Cleanseä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/modelcheck/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/\d+\.\d+/);


              if (match) {
                finalMetric1 = max(100 - parseFloat(match[0]),0)
                console.log("å‰ç«¯è¯»å–åˆ°çš„ final_metric1 =", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° final_metric1ï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 5 : 5
          console.log("SVD final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - minusValue)

          
          if (minusValue > 10) {
            methodStatuses[methodName] = "red"
          } else if (minusValue > 4) {
            methodStatuses[methodName] = "yellow"
          }else {
            methodStatuses[methodName] = "green"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - 10)
          return
        }
      }
      else if (methodName === "DeBackdoor") {
        try {
          // 1. å¯åŠ¨ä»»åŠ¡
          const startResp = await fetch(
            "http://127.0.0.1:9999/api/v1/system-manage/modelcheck/detector"
          )
          const startJson = await startResp.json()

          const taskId = startJson.task_id
          console.log("DeBackdoorä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

          // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
          let completed = false
          let finalMetric1 = null

          while (!completed) {
            await sleep(2000)

            const resp = await fetch(
              `http://127.0.0.1:9999/api/v1/system-manage/modelcheck/task/${taskId}`
            )
            const json = await resp.json()

            if (json.status === "completed") {
              completed = true

              const stdout = json.result?.stdout || ""
              const match = stdout.match(/\d+\.\d+/);


              if (match) {
                finalMetric1 = max(100 - parseFloat(match[0]),0)
                console.log("å‰ç«¯è¯»å–åˆ°çš„ final_metric1 =", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
              }
              else{
                console.log("æœªæ‰¾åˆ° final_metric1ï¼Œå°è¯•ä» stderr è¯»å–")
              }
            }
          }
          

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 5 : 5
          console.log("SVD final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - minusValue)

          
          if (minusValue > 10) {
            methodStatuses[methodName] = "red"
          } else if (minusValue > 4) {
            methodStatuses[methodName] = "yellow"
          }else {
            methodStatuses[methodName] = "green"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - 10)
          return
        }
      }

      else if (methodName === "Steps") {
        try {
        //   // 1. å¯åŠ¨ä»»åŠ¡
        //   const startResp = await fetch(
        //     "http://127.0.0.1:9999/api/v1/system-manage/modelcheck/detector"
        //   )
        //   const startJson = await startResp.json()

        //   const taskId = startJson.task_id
        //   console.log("DeBackdoorä»»åŠ¡å·²å¯åŠ¨ï¼ŒtaskId = ", taskId)

        //   // 2. æ¯ç§’è½®è¯¢ä»»åŠ¡çŠ¶æ€
        //   let completed = false
        //   let finalMetric1 = null

        //   while (!completed) {
        //     await sleep(2000)

        //     const resp = await fetch(
        //       `http://127.0.0.1:9999/api/v1/system-manage/modelcheck/task/${taskId}`
        //     )
        //     const json = await resp.json()

        //     if (json.status === "completed") {
        //       completed = true

        //       const stdout = json.result?.stdout || ""
        //       const match = stdout.match(/\d+\.\d+/);


        //       if (match) {
        //         finalMetric1 = max(100 - parseFloat(match[0]),0)
        //         console.log("å‰ç«¯è¯»å–åˆ°çš„ final_metric1 =", finalMetric1);  // â† å°±åŠ åœ¨è¿™é‡Œ
        //       }
        //       else{
        //         console.log("æœªæ‰¾åˆ° final_metric1ï¼Œå°è¯•ä» stderr è¯»å–")
        //       }
        //     }
        //   }

          await sleep(2000)
          finalMetric1 = 83.555

          // 3. è®¡ç®—å‡åˆ†
          const minusValue = finalMetric1 ? finalMetric1 / 5 : 5
          console.log("SVD final_metric1 =", finalMetric1, " å‡åˆ† =", minusValue)

          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - minusValue)

          
          if (minusValue > 10) {
            methodStatuses[methodName] = "red"
          } else if (minusValue > 4) {
            methodStatuses[methodName] = "yellow"
          }else {
            methodStatuses[methodName] = "green"
          }
          return  // â¬…ï¸ **å¿…é¡» returnï¼Œå¦åˆ™ä¼šè·‘åˆ°éšæœºæ¨¡æ‹Ÿ**
        } 
        catch (err) {
          console.error("CASSOCK è°ƒç”¨å¤±è´¥ï¼š", err)
          methodStatuses[methodName] = "red"
          stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] = Math.max(0, stageScores['åé—¨æ£€æµ‹ä¸ä¿®å¤'] - 10)
          return
        }
      }

      /* ==========================================
         ğŸ”¥ é CASSOCK â†’ ä»ç„¶ä¿æŒ Sleep æ¨¡æ‹Ÿ
      ========================================== */
      await sleep(2000)

      const rand = Math.random()
      let result = "green"
      if (rand > 0.7) result = "yellow"
      if (rand > 0.9) result = "red"

      methodStatuses[methodName] = result
      stageScores[stageName] = Math.max(0, stageScores[stageName] - (Math.random() * 3 + 1))
    }



    /* ==========================================
       ğŸ”¥ æ–°é€»è¾‘ï¼šæ‰€æœ‰ç»“æ„è°ƒç”¨åŒä¸€ä¸ª executeMethod
    ========================================== */
    if (isNested) {
      for (const subStageName of Object.keys(methods)) {
        // ç‰¹æ®Šå¤„ç†æ¨¡å‹è®­ç»ƒé˜¶æ®µï¼Œè®©å…¶æ–¹æ³•åŒæ—¶æ‰§è¡Œ
        if (subStageName === "æ¨¡å‹è®­ç»ƒé˜¶æ®µ") {
          const trainMethods = Object.keys(methods[subStageName]);
          // åŒæ—¶å°†æ‰€æœ‰æ–¹æ³•è®¾ç½®ä¸ºrunningçŠ¶æ€
          trainMethods.forEach(methodName => {
            currentMethod.value = methodName;
            methodStatuses[methodName] = "running";
          });
          
          // æ¨¡æ‹Ÿæ‰§è¡Œè¿‡ç¨‹
          await sleep(2000);
          
          // ç»Ÿä¸€ç”Ÿæˆä¸€ä¸ªéšæœºç»“æœ
          const rand = Math.random();
          let result = "green";
          if (rand > 0.7) result = "yellow";
          if (rand > 0.9) result = "red";
          
          // åŒæ—¶å°†æ‰€æœ‰æ–¹æ³•è®¾ç½®ä¸ºç›¸åŒçš„å®ŒæˆçŠ¶æ€
          trainMethods.forEach(methodName => {
            methodStatuses[methodName] = result;
          });
          
          // è®¡ç®—å‡åˆ†ï¼ˆåªå‡ä¸€æ¬¡ï¼‰
          stageScores[stageName] = Math.max(0, stageScores[stageName] - (Math.random() * 3 + 1));
        } else {
          // å…¶ä»–å­é˜¶æ®µä¿æŒåŸæœ‰é€»è¾‘
          for (const methodName of Object.keys(methods[subStageName])) {
            await executeMethod(methodName, stageName);
          }
        }
      }
    } else {
      for (const methodName of Object.keys(methods)) {
        await executeMethod(methodName, stageName);
      }
    }
  }

  isEvaluating.value = false
  currentMethod.value = ""
  currentStage.value = "å®Œæˆ"
}


onMounted(() => {
  runSimulation()
})
</script>

<style>
@keyframes wave {
  0% { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}

.animate-wave {
  animation: wave 3s linear infinite;
}

/* Custom scrollbar */
.custom-scrollbar::-webkit-scrollbar {
  width: 4px;
}
.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}
.custom-scrollbar::-webkit-scrollbar-thumb {
  background-color: #e5e7eb;
  border-radius: 20px;
}
</style>
